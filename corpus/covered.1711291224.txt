/root/rareskills-solidity/Foundry-ethernaut-solutions/echidna/DexEchidna.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.14;
  3 |     | 
  4 |     | import "../src/Dex/DexFactory.sol";
  5 |     | import "../src/Ethernaut.sol";
  6 |     | import "../src/Dex/Dex.sol";
  7 |     | 
  8 | *r  | contract DexEchidna {
  9 |     |     Ethernaut ethernaut;
 10 |     |     DexFactory factory;
 11 |     |     Dex dex;
 12 |     |     address token1Address;
 13 |     |     address token2Address;
 14 |     | 
 15 |     |     constructor() {
 16 |     |         ethernaut = new Ethernaut();
 17 |     |         factory = new DexFactory();
 18 |     |         ethernaut.registerLevel(factory);
 19 |     |         address levelAddress = ethernaut.createLevelInstance(factory);
 20 |     |         dex = Dex(payable(levelAddress));
 21 |     | 
 22 |     |         token1Address = dex.token1();
 23 |     |         token2Address = dex.token2();
 24 |     |         ERC20(token1Address).approve(address(dex), type(uint256).max);
 25 |     |         ERC20(token2Address).approve(address(dex), type(uint256).max);
 26 |     |     }
 27 |     | 
 28 | *   |     function add_liquidity(bool token1) public {
 29 | *   |         if (token1) {
 30 | *   |             uint256 amount = ERC20(token1Address).balanceOf(address(this));
 31 | *r  |             dex.add_liquidity(token1Address, amount);
 32 |     |         } else {
 33 | *   |             uint256 amount = ERC20(token2Address).balanceOf(address(this));
 34 | *   |             dex.add_liquidity(token2Address, amount);
 35 |     |         }
 36 |     |     }
 37 |     | 
 38 | *   |     function swap(bool a2b) public {
 39 | *   |         uint256 amount;
 40 | *   |         if (a2b) {
 41 | *   |             amount = ERC20(token1Address).balanceOf(address(this));
 42 | *   |             dex.swap(token1Address, token2Address, amount);
 43 |     |         } else {
 44 | *   |             amount = ERC20(token2Address).balanceOf(address(this));
 45 | *   |             dex.swap(token2Address, token1Address, amount);
 46 |     |         }
 47 |     |     }
 48 |     | 
 49 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 50 |     |         return a <= b ? a : b;
 51 |     |     }
 52 |     | 
 53 | *   |     function testSolved() public {
 54 | *   |         assert(ERC20(token1Address).balanceOf(address(dex)) > 85);
 55 | *   |         assert(ERC20(token2Address).balanceOf(address(dex)) > 85);
 56 |     |     }
 57 |     | }
 58 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/lib/openzeppelin-contracts/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions anymore. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby removing any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 | *   | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 | *   |     ) public virtual override returns (bool) {
 163 |     |         address spender = _msgSender();
 164 | *   |         _spendAllowance(from, spender, amount);
 165 | *   |         _transfer(from, to, amount);
 166 | *   |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 | *   |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *   |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 |     |     ) internal virtual {
 231 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 |     |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 | *   |         uint256 fromBalance = _balances[from];
 237 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 | *   |             _balances[from] = fromBalance - amount;
 240 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 241 |     |             // decrementing then incrementing.
 242 | *   |             _balances[to] += amount;
 243 |     |         }
 244 |     | 
 245 | *   |         emit Transfer(from, to, amount);
 246 |     | 
 247 | *   |         _afterTokenTransfer(from, to, amount);
 248 |     |     }
 249 |     | 
 250 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 251 |     |      * the total supply.
 252 |     |      *
 253 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 254 |     |      *
 255 |     |      * Requirements:
 256 |     |      *
 257 |     |      * - `account` cannot be the zero address.
 258 |     |      */
 259 |     |     function _mint(address account, uint256 amount) internal virtual {
 260 |     |         require(account != address(0), "ERC20: mint to the zero address");
 261 |     | 
 262 |     |         _beforeTokenTransfer(address(0), account, amount);
 263 |     | 
 264 |     |         _totalSupply += amount;
 265 |     |         unchecked {
 266 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 267 |     |             _balances[account] += amount;
 268 |     |         }
 269 |     |         emit Transfer(address(0), account, amount);
 270 |     | 
 271 |     |         _afterTokenTransfer(address(0), account, amount);
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 276 |     |      * total supply.
 277 |     |      *
 278 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 279 |     |      *
 280 |     |      * Requirements:
 281 |     |      *
 282 |     |      * - `account` cannot be the zero address.
 283 |     |      * - `account` must have at least `amount` tokens.
 284 |     |      */
 285 |     |     function _burn(address account, uint256 amount) internal virtual {
 286 |     |         require(account != address(0), "ERC20: burn from the zero address");
 287 |     | 
 288 |     |         _beforeTokenTransfer(account, address(0), amount);
 289 |     | 
 290 |     |         uint256 accountBalance = _balances[account];
 291 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 292 |     |         unchecked {
 293 |     |             _balances[account] = accountBalance - amount;
 294 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 295 |     |             _totalSupply -= amount;
 296 |     |         }
 297 |     | 
 298 |     |         emit Transfer(account, address(0), amount);
 299 |     | 
 300 |     |         _afterTokenTransfer(account, address(0), amount);
 301 |     |     }
 302 |     | 
 303 |     |     /**
 304 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 305 |     |      *
 306 |     |      * This internal function is equivalent to `approve`, and can be used to
 307 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 308 |     |      *
 309 |     |      * Emits an {Approval} event.
 310 |     |      *
 311 |     |      * Requirements:
 312 |     |      *
 313 |     |      * - `owner` cannot be the zero address.
 314 |     |      * - `spender` cannot be the zero address.
 315 |     |      */
 316 | *   |     function _approve(
 317 |     |         address owner,
 318 |     |         address spender,
 319 |     |         uint256 amount
 320 |     |     ) internal virtual {
 321 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 322 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 323 |     | 
 324 | *   |         _allowances[owner][spender] = amount;
 325 | *   |         emit Approval(owner, spender, amount);
 326 |     |     }
 327 |     | 
 328 |     |     /**
 329 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 330 |     |      *
 331 |     |      * Does not update the allowance amount in case of infinite allowance.
 332 |     |      * Revert if not enough allowance is available.
 333 |     |      *
 334 |     |      * Might emit an {Approval} event.
 335 |     |      */
 336 | *   |     function _spendAllowance(
 337 |     |         address owner,
 338 |     |         address spender,
 339 |     |         uint256 amount
 340 | *   |     ) internal virtual {
 341 | *   |         uint256 currentAllowance = allowance(owner, spender);
 342 | *   |         if (currentAllowance != type(uint256).max) {
 343 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 344 |     |             unchecked {
 345 | *   |                 _approve(owner, spender, currentAllowance - amount);
 346 |     |             }
 347 |     |         }
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * will be transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 | *   |     function _beforeTokenTransfer(
 365 |     |         address from,
 366 |     |         address to,
 367 |     |         uint256 amount
 368 |     |     ) internal virtual {}
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 372 |     |      * minting and burning.
 373 |     |      *
 374 |     |      * Calling conditions:
 375 |     |      *
 376 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 377 |     |      * has been transferred to `to`.
 378 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 379 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 380 |     |      * - `from` and `to` are never both zero.
 381 |     |      *
 382 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 383 |     |      */
 384 |     |     function _afterTokenTransfer(
 385 |     |         address from,
 386 |     |         address to,
 387 |     |         uint256 amount
 388 |     |     ) internal virtual {}
 389 |     | }
 390 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | // CAUTION
   7 |     | // This version of SafeMath should only be used with Solidity 0.8 or later,
   8 |     | // because it relies on the compiler's built in overflow checks.
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Wrappers over Solidity's arithmetic operations.
  12 |     |  *
  13 |     |  * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
  14 |     |  * now has built in overflow checking.
  15 |     |  */
  16 |     | library SafeMath {
  17 |     |     /**
  18 |     |      * @dev Returns the addition of two unsigned integers, with an overflow flag.
  19 |     |      *
  20 |     |      * _Available since v3.4._
  21 |     |      */
  22 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  23 |     |         unchecked {
  24 |     |             uint256 c = a + b;
  25 |     |             if (c < a) return (false, 0);
  26 |     |             return (true, c);
  27 |     |         }
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
  32 |     |      *
  33 |     |      * _Available since v3.4._
  34 |     |      */
  35 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  36 |     |         unchecked {
  37 |     |             if (b > a) return (false, 0);
  38 |     |             return (true, a - b);
  39 |     |         }
  40 |     |     }
  41 |     | 
  42 |     |     /**
  43 |     |      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
  44 |     |      *
  45 |     |      * _Available since v3.4._
  46 |     |      */
  47 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  48 |     |         unchecked {
  49 |     |             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  50 |     |             // benefit is lost if 'b' is also tested.
  51 |     |             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  52 |     |             if (a == 0) return (true, 0);
  53 |     |             uint256 c = a * b;
  54 |     |             if (c / a != b) return (false, 0);
  55 |     |             return (true, c);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the division of two unsigned integers, with a division by zero flag.
  61 |     |      *
  62 |     |      * _Available since v3.4._
  63 |     |      */
  64 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  65 |     |         unchecked {
  66 |     |             if (b == 0) return (false, 0);
  67 |     |             return (true, a / b);
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
  73 |     |      *
  74 |     |      * _Available since v3.4._
  75 |     |      */
  76 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  77 |     |         unchecked {
  78 |     |             if (b == 0) return (false, 0);
  79 |     |             return (true, a % b);
  80 |     |         }
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Returns the addition of two unsigned integers, reverting on
  85 |     |      * overflow.
  86 |     |      *
  87 |     |      * Counterpart to Solidity's `+` operator.
  88 |     |      *
  89 |     |      * Requirements:
  90 |     |      *
  91 |     |      * - Addition cannot overflow.
  92 |     |      */
  93 |     |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
  94 |     |         return a + b;
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
  99 |     |      * overflow (when the result is negative).
 100 |     |      *
 101 |     |      * Counterpart to Solidity's `-` operator.
 102 |     |      *
 103 |     |      * Requirements:
 104 |     |      *
 105 |     |      * - Subtraction cannot overflow.
 106 |     |      */
 107 |     |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
 108 |     |         return a - b;
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 113 |     |      * overflow.
 114 |     |      *
 115 |     |      * Counterpart to Solidity's `*` operator.
 116 |     |      *
 117 |     |      * Requirements:
 118 |     |      *
 119 |     |      * - Multiplication cannot overflow.
 120 |     |      */
 121 |     |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
 122 |     |         return a * b;
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 127 |     |      * division by zero. The result is rounded towards zero.
 128 |     |      *
 129 |     |      * Counterpart to Solidity's `/` operator.
 130 |     |      *
 131 |     |      * Requirements:
 132 |     |      *
 133 |     |      * - The divisor cannot be zero.
 134 |     |      */
 135 |     |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
 136 |     |         return a / b;
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 141 |     |      * reverting when dividing by zero.
 142 |     |      *
 143 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 144 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 145 |     |      * invalid opcode to revert (consuming all remaining gas).
 146 |     |      *
 147 |     |      * Requirements:
 148 |     |      *
 149 |     |      * - The divisor cannot be zero.
 150 |     |      */
 151 |     |     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
 152 |     |         return a % b;
 153 |     |     }
 154 |     | 
 155 |     |     /**
 156 |     |      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
 157 |     |      * overflow (when the result is negative).
 158 |     |      *
 159 |     |      * CAUTION: This function is deprecated because it requires allocating memory for the error
 160 |     |      * message unnecessarily. For custom revert reasons use {trySub}.
 161 |     |      *
 162 |     |      * Counterpart to Solidity's `-` operator.
 163 |     |      *
 164 |     |      * Requirements:
 165 |     |      *
 166 |     |      * - Subtraction cannot overflow.
 167 |     |      */
 168 |     |     function sub(
 169 |     |         uint256 a,
 170 |     |         uint256 b,
 171 |     |         string memory errorMessage
 172 |     |     ) internal pure returns (uint256) {
 173 |     |         unchecked {
 174 |     |             require(b <= a, errorMessage);
 175 |     |             return a - b;
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /**
 180 |     |      * @dev Returns the integer division of two unsigned integers, reverting with custom message on
 181 |     |      * division by zero. The result is rounded towards zero.
 182 |     |      *
 183 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 184 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 185 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 186 |     |      *
 187 |     |      * Requirements:
 188 |     |      *
 189 |     |      * - The divisor cannot be zero.
 190 |     |      */
 191 |     |     function div(
 192 |     |         uint256 a,
 193 |     |         uint256 b,
 194 |     |         string memory errorMessage
 195 |     |     ) internal pure returns (uint256) {
 196 |     |         unchecked {
 197 |     |             require(b > 0, errorMessage);
 198 |     |             return a / b;
 199 |     |         }
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 204 |     |      * reverting with custom message when dividing by zero.
 205 |     |      *
 206 |     |      * CAUTION: This function is deprecated because it requires allocating memory for the error
 207 |     |      * message unnecessarily. For custom revert reasons use {tryMod}.
 208 |     |      *
 209 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 210 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 211 |     |      * invalid opcode to revert (consuming all remaining gas).
 212 |     |      *
 213 |     |      * Requirements:
 214 |     |      *
 215 |     |      * - The divisor cannot be zero.
 216 |     |      */
 217 |     |     function mod(
 218 |     |         uint256 a,
 219 |     |         uint256 b,
 220 |     |         string memory errorMessage
 221 |     |     ) internal pure returns (uint256) {
 222 |     |         unchecked {
 223 |     |             require(b > 0, errorMessage);
 224 |     |             return a % b;
 225 |     |         }
 226 |     |     }
 227 |     | }
 228 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/src/BaseLevel.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.14;
  4 |     | 
  5 |     | import "openzeppelin-contracts/contracts/access/Ownable.sol";
  6 |     | 
  7 |     | abstract contract Level is Ownable {
  8 |     |     function createInstance(address _player)
  9 |     |         public
 10 |     |         payable
 11 |     |         virtual
 12 |     |         returns (address);
 13 |     | 
 14 |     |     function validateInstance(address payable _instance, address _player)
 15 |     |         public
 16 |     |         virtual
 17 |     |         returns (bool);
 18 |     | }
 19 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/src/Dex/Dex.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.14;
  3 |     | 
  4 |     | import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
  5 |     | import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
  6 |     | import "openzeppelin-contracts/contracts/utils/math/SafeMath.sol";
  7 |     | 
  8 | *   | contract Dex {
  9 |     |     using SafeMath for uint;
 10 |     |     address public token1;
 11 |     |     address public token2;
 12 |     | 
 13 |     |     constructor(address _token1, address _token2) public {
 14 |     |         token1 = _token1;
 15 |     |         token2 = _token2;
 16 |     |     }
 17 |     | 
 18 | *   |     function swap(
 19 |     |         address from,
 20 |     |         address to,
 21 |     |         uint amount
 22 | *   |     ) public {
 23 | *   |         require(
 24 | *   |             (from == token1 && to == token2) ||
 25 | *   |                 (from == token2 && to == token1),
 26 |     |             "Invalid tokens"
 27 |     |         );
 28 | *   |         require(
 29 | *   |             IERC20(from).balanceOf(msg.sender) >= amount,
 30 |     |             "Not enough to swap"
 31 |     |         );
 32 | *   |         uint swap_amount = get_swap_price(from, to, amount);
 33 | *   |         IERC20(from).transferFrom(msg.sender, address(this), amount);
 34 | *   |         IERC20(to).approve(address(this), swap_amount);
 35 | *   |         IERC20(to).transferFrom(address(this), msg.sender, swap_amount);
 36 |     |     }
 37 |     | 
 38 | *   |     function add_liquidity(address token_address, uint amount) public {
 39 | *   |         IERC20(token_address).transferFrom(msg.sender, address(this), amount);
 40 |     |     }
 41 |     | 
 42 | *   |     function get_swap_price(
 43 |     |         address from,
 44 |     |         address to,
 45 |     |         uint amount
 46 | *   |     ) public view returns (uint) {
 47 | *   |         return ((amount * IERC20(to).balanceOf(address(this))) /
 48 | *   |             IERC20(from).balanceOf(address(this)));
 49 |     |     }
 50 |     | 
 51 | *   |     function approve(address spender, uint amount) public {
 52 |     |         SwappableToken(token1).approve(spender, amount);
 53 | *   |         SwappableToken(token2).approve(spender, amount);
 54 |     |     }
 55 |     | 
 56 | *   |     function balanceOf(address token, address account)
 57 |     |         public
 58 |     |         view
 59 |     |         returns (uint)
 60 |     |     {
 61 |     |         return IERC20(token).balanceOf(account);
 62 |     |     }
 63 |     | }
 64 |     | 
 65 | *   | contract SwappableToken is ERC20 {
 66 |     |     constructor(
 67 |     |         string memory name,
 68 |     |         string memory symbol,
 69 |     |         uint initialSupply
 70 |     |     ) public ERC20(name, symbol) {
 71 |     |         _mint(msg.sender, initialSupply);
 72 |     |     }
 73 |     | }
 74 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/src/Dex/DexFactory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.14;
  4 |     | 
  5 |     | import '../BaseLevel.sol';
  6 |     | import './Dex.sol';
  7 |     | import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
  8 |     | 
  9 |     | 
 10 |     | contract DexFactory is Level {
 11 |     | 
 12 |     |   function createInstance(address _player) override public payable returns (address) {
 13 |     |     SwappableToken token_instance = new SwappableToken("Token 1", "TKN1", 110);
 14 |     |     SwappableToken token_instance_two = new SwappableToken("Token 2", "TKN2", 110);
 15 |     |     address token_instance_address = address(token_instance);
 16 |     |     address token_instance_two_address = address(token_instance_two);
 17 |     |     Dex instance = new Dex(token_instance_address, token_instance_two_address);
 18 |     | 
 19 |     |     token_instance.approve(address(instance), 100);
 20 |     |     token_instance_two.approve(address(instance), 100);
 21 |     |     instance.add_liquidity(address(token_instance), 100);
 22 |     |     instance.add_liquidity(address(token_instance_two), 100);
 23 |     |     token_instance.transfer(_player, 10);
 24 |     |     token_instance_two.transfer(_player, 10);
 25 |     |     return address(instance);
 26 |     |   }
 27 |     | 
 28 |     |   function validateInstance(address payable _instance, address) override public returns (bool) {
 29 |     |     address token1 = Dex(_instance).token1();
 30 |     |     address token2 = Dex(_instance).token2();
 31 |     |     return IERC20(token1).balanceOf(_instance) == 0 || ERC20(token2).balanceOf(_instance) == 0;
 32 |     |   }
 33 |     | }
 34 |     | 

/root/rareskills-solidity/Foundry-ethernaut-solutions/src/Ethernaut.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.14;
  4 |     | 
  5 |     | import "./BaseLevel.sol";
  6 |     | import "openzeppelin-contracts/contracts/access/Ownable.sol";
  7 |     | 
  8 |     | contract Ethernaut is Ownable {
  9 |     |     // ----------------------------------
 10 |     |     // Owner interaction
 11 |     |     // ----------------------------------
 12 |     | 
 13 |     |     mapping(address => bool) registeredLevels;
 14 |     | 
 15 |     |     // Only registered levels will be allowed to generate and validate level instances.
 16 |     |     function registerLevel(Level _level) public onlyOwner {
 17 |     |         registeredLevels[address(_level)] = true;
 18 |     |     }
 19 |     | 
 20 |     |     // ----------------------------------
 21 |     |     // Get/submit level instances
 22 |     |     // ----------------------------------
 23 |     | 
 24 |     |     struct EmittedInstanceData {
 25 |     |         address player;
 26 |     |         Level level;
 27 |     |         bool completed;
 28 |     |     }
 29 |     | 
 30 |     |     mapping(address => EmittedInstanceData) emittedInstances;
 31 |     | 
 32 |     |     event LevelInstanceCreatedLog(address indexed player, address instance);
 33 |     |     event LevelCompletedLog(address indexed player, Level level);
 34 |     | 
 35 |     |     function createLevelInstance(Level _level)
 36 |     |         public
 37 |     |         payable
 38 |     |         returns (address)
 39 |     |     {
 40 |     |         // Ensure level is registered.
 41 |     |         require(registeredLevels[address(_level)]);
 42 |     | 
 43 |     |         // Get level factory to create an instance.
 44 |     |         address instance = _level.createInstance{value: msg.value}(msg.sender);
 45 |     | 
 46 |     |         // Store emitted instance relationship with player and level.
 47 |     |         emittedInstances[instance] = EmittedInstanceData(
 48 |     |             msg.sender,
 49 |     |             _level,
 50 |     |             false
 51 |     |         );
 52 |     | 
 53 |     |         // Retrieve created instance via logs.
 54 |     |         emit LevelInstanceCreatedLog(msg.sender, instance);
 55 |     | 
 56 |     |         return instance; // Return data - not possible to read emitted events via solidity
 57 |     |     }
 58 |     | 
 59 |     |     function submitLevelInstance(address payable _instance)
 60 |     |         public
 61 |     |         returns (bool)
 62 |     |     {
 63 |     |         // Get player and level.
 64 |     |         EmittedInstanceData storage data = emittedInstances[_instance];
 65 |     |         require(data.player == msg.sender); // instance was emitted for this player
 66 |     |         require(data.completed == false); // not already submitted
 67 |     | 
 68 |     |         // Have the level check the instance.
 69 |     |         if (data.level.validateInstance(_instance, msg.sender)) {
 70 |     |             // Register instance as completed.
 71 |     |             data.completed = true;
 72 |     | 
 73 |     |             // Notify success via logs.
 74 |     |             emit LevelCompletedLog(msg.sender, data.level);
 75 |     | 
 76 |     |             return true; // Return data - not possible to read emitted events
 77 |     |         }
 78 |     | 
 79 |     |         return false; // Return data - not possible to read emitted events via solidity
 80 |     |     }
 81 |     | }
 82 |     | 

